<!DOCTYPE html>
<html lang="en">
<head>
<script>document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')</script>
<script id="shade_vert" type="x-shader/x-vertex">
attribute vec3 vPosition,vNormal;
varying vec3 fragmentNormal;
mat4 projection = mat4(1.3,0,0,0,0,1.73,0,0,0,0,-1,-1,0,0,-.2,0);
uniform float time;
vec3 lightPosition = vec3(0,0,2);
varying vec3 lightVector;
varying vec3 cameraVector;

mat4 translate(vec3 pos) {
  mat4 m = mat4(1.0);
  m[3][0] = pos[0];
  m[3][1] = pos[1];
  m[3][2] = pos[2];
  return m;
}

mat3 rx(float t) {
  return mat3(
  1,      0,       0,
  0, cos(t), -sin(t),
  0, sin(t),  cos(t)
  );
}

mat3 ry(float t) {
  return mat3(
  cos(t), 0, sin(t),
  0, 1, 0,
  -sin(t), 0, cos(t)
  );
}

mat4 view(mat3 R, vec3 P) {
  mat4 result = mat4(mat3(R));
  result[3] = vec4(P, 1);
  return result;
}

mat4 transpose(mat4 m) {
  return mat4(
    m[0][0], m[1][0], m[2][0], m[3][0],
    m[0][1], m[1][1], m[2][1], m[3][1],
    m[0][2], m[1][2], m[2][2], m[3][2],
    m[0][3], m[1][3], m[2][3], m[3][3]
  );
}

mat4 viewInv(mat3 R, vec3 P) {
  mat3 Rt;
  Rt = mat3(
    R[0][0], R[1][0], R[2][0],
    R[0][1], R[1][1], R[2][1],
    R[0][2], R[1][2], R[2][2]
  );
  mat4 result = mat4(Rt);
  result[3] = vec4(-Rt * P, 1);
  return transpose(result);
}

void main() {
  float t = time * 0.3;
  vec3 pos = vec3(0,0,-3.0 + sin(t*1.5));
  //vec3 pos = vec3(0,0,-3.0);
  //mat3 rot;
  //rot = rx(sin(t)*6.0);
  mat3 rot = ry(sin(t)*6.0);
  //mat3 rot = ry(1.5 + 3.0*cos(t*3.0));
  //mat3 rot = mat3(1.0);

  mat4 vTransform = view   (rot, pos);
  mat4 nTransform = viewInv(rot, pos);

  vec4 vPos = vTransform * vec4(vPosition, 1);
  vec4 nPos = nTransform * vec4(-vNormal,   1);

  gl_Position    = (projection * vPos);
  fragmentNormal = (projection * nPos).xyz;

  lightVector  = lightPosition - vPos.xyz;
  cameraVector = vec3(0,0,0)   - vPos.xyz;
}
</script>
<script id="shade_frag" type="x-shader/x-fragment">
precision mediump float;
uniform float time;

varying vec3 fragmentNormal;
varying vec3 lightVector;
varying vec3 cameraVector;

float MAX_DIST = 6.0;
float MAX_DIST_SQ = MAX_DIST * MAX_DIST;
void main(void){
  //vec3 lightColor = vec3(sin(time),cos(time*2.0),0.5);
  vec3 lightColor = vec3(1);

  vec3 normal    = normalize(fragmentNormal);
  vec3 cameraDir = normalize(cameraVector);
  vec3 lightDir  = normalize(lightVector);

  float dist       = min(dot(lightVector, lightVector), MAX_DIST_SQ) / MAX_DIST_SQ;
  float distFactor = 1.0 - dist;
  
  float diffuseDot = dot(normal, lightDir);
  vec3 diffuse = lightColor * clamp(diffuseDot, 0.0, 1.0) * distFactor;

  vec3 halfAngle = normalize(cameraDir + lightDir);
  vec3 specularColor = vec3(1,0,0);
  float specularDot = dot(normal, halfAngle);
  vec3 specular = specularColor * pow(clamp(specularDot, 0.0, 1.0), 20.0) * distFactor;

  //gl_FragColor = vec4(clamp(specular, 0.0, 1.0), 1);
  //gl_FragColor = vec4(specularDot, 0, 0, 1);
  //gl_FragColor = vec4(clamp(diffuse, 0.0, 1.0), 1);
  gl_FragColor = vec4(clamp(specular, 0.0, 1.0), 1);
  //gl_FragColor = vec4(diffuse.x, 0, 0, 1);
  
  //gl_FragColor = vec4(halfAngle.z,0,0, 1);  
  
}</script>
</head><body><canvas id="c" width="640" height="480"></canvas>
<script src="js/main.js"></script>
<!--<script src="dist/Cube.min.js"></script>-->
</body></html>

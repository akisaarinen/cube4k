<!DOCTYPE html>
<html lang="en">
<head>
<title>Shader</title>
<script>document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')</script>
<script id="shade_vert" type="x-shader/x-vertex">
    precision mediump float;
    
    uniform mat4 gProjectionMatrix;
    uniform mat4 gModelViewMatrix;
    uniform mat4 gNormalMatrix;

    uniform mat3 gRotate;
    uniform vec3 gTranslate;
    
    uniform vec4 gLightPos;
    uniform vec4 gColor;

    uniform float gAngleX;
    
    attribute vec3 vPosition;
    attribute vec3 vNormal;
    
    varying vec4 fColor;

    mat4 transpose(mat4 R) {
      return mat4(
        R[0][0], R[1][0], R[2][0], R[3][0],
        R[0][1], R[1][1], R[2][1], R[3][1],
        R[0][2], R[1][2], R[2][2], R[3][2],
        R[0][3], R[1][3], R[2][3], R[3][3]
      );
    }

    mat3 transpose(mat3 R) {
      return mat3(
        R[0][0], R[1][0], R[2][0],
        R[0][1], R[1][1], R[2][1],
        R[0][2], R[1][2], R[2][2]
      );
    }

    mat4 inverse(mat3 R, vec3 t)
    {
      mat3 Rt = transpose(R);
      vec3 th = Rt*t;
      return mat4(
        R[0][0], R[1][0], R[2][0], 0,
        R[0][1], R[1][1], R[2][1], 0,
        R[0][2], R[1][2], R[2][2], 0,
        -th[0],  -th[1],  -th[2],  1
      );
    }

    mat3 rotatex(float t) {
      return mat3(
          1,      0,       0,
          0, cos(t), -sin(t),
          0, sin(t),  cos(t)
      );
    }
    mat3 rotatey(float t) {
      return mat3(
         cos(t), 0, sin(t),
        0,       1,      0,
        -sin(t), 0, cos(t)
      );
    }
    mat3 rotatez(float t) {
      return mat3(
        cos(t), -sin(t), 0,
        sin(t),  cos(t), 0,
             0,       0, 1
      );
    }

    mat4 view4(mat3 M) {
      return mat4(
        M[0][0], M[0][1], M[0][2], 0,
        M[1][0], M[1][1], M[1][2], 0,
        M[2][0], M[2][1], M[2][2], 0,
        0, 0, 0, 1
      );
    }
    
    void main(void)
    {
        vec4 eyeNorm, eyePos, lightDir, pos;
        mat4 dummy;
        float NdotL, diffuse;

        mat3 R = rotatex(gAngleX) * rotatey(gAngleX/2.0);

        mat4 view = gModelViewMatrix * view4(R);
        mat4 normal = gModelViewMatrix * transpose(inverse(R, gTranslate));

        eyeNorm = normalize(normal * vec4(vNormal, 0));
        eyePos  = view * vec4(vPosition, 1);        
        
        lightDir = normalize(gLightPos - eyePos);
        NdotL = max(dot(eyeNorm.xyz, lightDir.xyz), 0.0);
        
        fColor = vec4(gColor.rgb * NdotL, 1);
        
        pos = vec4(vPosition, 1);
        gl_Position = gProjectionMatrix * view * pos;
    }
</script>
<!--
      M = {
        {R11, R12, R13, 0},
        {R21, R22, R23, 0},
        {R31, R32, R33, 0},
        {tx, ty, tz, 1},
      };

      Rt = {
        {R11, R21, R31},
        {R12, R22, R32},
        {R13, R23, R33}
      }

      Rt*t = t'

      M-1 = {
        {R11, R21, R31, 0},
        {R12, R22, R32, 0},
        {R13, R23, R33, 0},
        {-t'x, -t'y, -t'z, 1},
      };
      -->
<script id="shade_frag" type="x-shader/x-fragment">

    //#version 100
    // Must specify precision in WebGL frag shaders
    precision mediump float;
    
    varying vec4 fColor;
    varying vec4 bColor;
    
    void main(void)
    {
        // Want to see polygons in wrong order
        if (gl_FrontFacing)
            gl_FragColor = fColor;
        else
            gl_FragColor = vec4(1,0,0,1);
    }
</script>
<script src="gpu.js"></script>
<script src="glDegMatrix.js"></script>
<script>

function start() {
  var canvas = document.getElementById("glcanvas");
  gl = canvas.getContext("webgl");

  gl.viewportWidth = canvas.width;
  gl.viewportHeight = canvas.height;

  gl.clearColor(0.0, 0.0, 0.0, 1.0);                      // Set clear color to black, fully opaque
  gl.enable(gl.DEPTH_TEST);                               // Enable depth testing
  gl.depthFunc(gl.LEQUAL);                                // Near things obscure far things
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);      // Clear the color as well as the depth buffer.

  mat4.identity(pMatrix);
  mat4.identity(mvMatrix);

  initShaders();
  myCube();
  drawPicture(gl);
}

var initShaders = function()
{
  var vShader, fShader;

  vShader = gpu.loadShader(gl.VERTEX_SHADER, "shade_vert");
  fShader = gpu.loadShader(gl.FRAGMENT_SHADER, "shade_frag");
  gpuShade = gpu.newProgram(vShader, fShader);

  hProjectionMatrix = gl.getUniformLocation(gpuShade, "gProjectionMatrix");
  hModelViewMatrix  = gl.getUniformLocation(gpuShade, "gModelViewMatrix");
  hNormalMatrix     = gl.getUniformLocation(gpuShade, "gNormalMatrix");
  hLightPos         = gl.getUniformLocation(gpuShade, "gLightPos");

  hRotate            = gl.getUniformLocation(gpuShade, "gRotate");
  hTranslate         = gl.getUniformLocation(gpuShade, "gTranslate");
  hAngleX         = gl.getUniformLocation(gpuShade, "gAngleX");

  hColor            = gl.getUniformLocation(gpuShade, "gColor");
  hColor            = gl.getUniformLocation(gpuShade, "gColor");

  vaPosition = gl.getAttribLocation(gpuShade, "vPosition");
  vaNormal   = gl.getAttribLocation(gpuShade, "vNormal");
};

function drawPicture(gl)
{
  // Clear the canvas
  gl.viewport(0,0, gl.viewportWidth, gl.viewportHeight);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  setProjection();
  setViewpoint();
  drawWorld();
  requestAnimationFrame(function() { drawPicture(gl); });
}


var pMatrix = mat4.create();
var mvMatrix = mat4.create();

function setProjection() {
  //mat4.perspective(60, gl.viewportWidth / gl.viewportHeight, 0.1, 10, pMatrix);
  pMatrix = new Float32Array(
  [1.299038052558899, 0, 0, 0, 
   0, 1.7320507764816284, 0, 0, 
   0, 0, -1.0202020406723022, -1, 
   0, 0, -0.20202019810676575, 0]);
}

function setViewpoint() {
  //mat4.lookAt([0, 2, 4], [0,0,0], [0,1,0], mvMatrix);
  mvMatrix = new Float32Array(
    [1, 0, 0, 0, 
    0, 0.8944271802902222, 0.4472135901451111, 0, 
    0, -0.4472135901451111, 0.8944271802902222, 0, 
    0, 0, -4.4721360206604, 1]
  );
}

// Cube geometry
var cubeVerts = new Float32Array([
    -0.5,  0.5,  0.5,   // 0
    -0.5, -0.5,  0.5,
     0.5,  0.5,  0.5,
     0.5, -0.5,  0.5,
    -0.5,  0.5, -0.5,   // 4
    -0.5, -0.5, -0.5,
    -0.5,  0.5,  0.5,
    -0.5, -0.5,  0.5,
     0.5,  0.5, -0.5,   // 8
    -0.5,  0.5, -0.5,
     0.5,  0.5,  0.5,
    -0.5,  0.5,  0.5,
     0.5,  0.5,  0.5,   // 12
     0.5, -0.5,  0.5,
     0.5,  0.5, -0.5,
     0.5, -0.5, -0.5,
     0.5, -0.5,  0.5,   // 16
    -0.5, -0.5,  0.5,
     0.5, -0.5, -0.5,
    -0.5, -0.5, -0.5,
     0.5,  0.5, -0.5,   // 20
     0.5, -0.5, -0.5,
    -0.5,  0.5, -0.5,
    -0.5, -0.5, -0.5,
]);

var cubeNorms = new Float32Array([
     0,  0,  1,
     0,  0,  1,
     0,  0,  1,
     0,  0,  1,
    -1,  0,  0,
    -1,  0,  0,
    -1,  0,  0,
    -1,  0,  0,
     0,  1,  0,
     0,  1,  0,
     0,  1,  0,
     0,  1,  0,
     1,  0,  0,
     1,  0,  0,
     1,  0,  0,
     1,  0,  0,
     0, -1,  0,
     0, -1,  0,
     0, -1,  0,
     0, -1,  0,
     0,  0, -1,
     0,  0, -1,
     0,  0, -1,
     0,  0, -1,
]);

var cubeIdx = new Uint16Array([
     0,  1,  2,  1,  3,  2,
     4,  5,  6,  5,  7,  6,
     8,  9, 10,  9, 11, 10,
    12, 13, 14, 13, 15, 14,
    16, 17, 18, 17, 19, 18,
    20, 21, 22, 21, 23, 22,
]);

var myCube = function()
{
        // Transfer data to GPU
        cubeVBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBuf);
        gl.bufferData(gl.ARRAY_BUFFER, cubeVerts, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        
        cubeNBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeNBuf);
        gl.bufferData(gl.ARRAY_BUFFER, cubeNorms, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        
        cubeIdxBuf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIdxBuf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIdx, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
};


var mat4rotate = function(mat, angle, axis, dest) {
        var x = axis[0], y = axis[1], z = axis[2];
        var len = Math.sqrt(x*x + y*y + z*z);
        if (!len) { return null; }
        if (len !== 1) {
                len = 1 / len;
                x *= len; 
                y *= len; 
                z *= len;
        }
        
        angle = Math.radians(angle);
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        var t = 1-c;
        
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
        var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
        var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
        
        // Construct the elements of the rotation matrix
        var b00 = x*x*t + c, b01 = y*x*t + z*s, b02 = z*x*t - y*s;
        var b10 = x*y*t - z*s, b11 = y*y*t + c, b12 = z*y*t + x*s;
        var b20 = x*z*t + y*s, b21 = y*z*t - x*s, b22 = z*z*t + c;
        
        if (!dest) { 
                dest = mat; 
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
                dest[12] = mat[12];
                dest[13] = mat[13];
                dest[14] = mat[14];
                dest[15] = mat[15];
        }
        
        // Perform rotation-specific matrix multiplication
        dest[0] = a00*b00 + a10*b01 + a20*b02;
        dest[1] = a01*b00 + a11*b01 + a21*b02;
        dest[2] = a02*b00 + a12*b01 + a22*b02;
        dest[3] = a03*b00 + a13*b01 + a23*b02;
        
        dest[4] = a00*b10 + a10*b11 + a20*b12;
        dest[5] = a01*b10 + a11*b11 + a21*b12;
        dest[6] = a02*b10 + a12*b11 + a22*b12;
        dest[7] = a03*b10 + a13*b11 + a23*b12;
        
        dest[8] = a00*b20 + a10*b21 + a20*b22;
        dest[9] = a01*b20 + a11*b21 + a21*b22;
        dest[10] = a02*b20 + a12*b21 + a22*b22;
        dest[11] = a03*b20 + a13*b21 + a23*b22;
        return dest;
};

function drawWorld() {
  //mat4rotate(mvMatrix, currentAngle, [0,1,0], mvMatrix);

  cubeColor = [0,1,0,1];

  gl.useProgram(gpuShade);

  gl.uniformMatrix4fv(hProjectionMatrix, false, pMatrix);
  gl.uniformMatrix4fv(hModelViewMatrix, false, mvMatrix);
  //gl.uniformMatrix4fv(hNormalMatrix, false, nvMatrix);
  
  var rotationMatrix = new Float32Array([
    1, 0, 0,
    0, 1, 0,
    0, 0, 1
  ]);
  
  var translateVector = new Float32Array([0, 0, 0]);

  gl.uniformMatrix3fv(hRotate, false, rotationMatrix);
  gl.uniform1f(hAngleX, currentAngle / 2.0 / Math.PI);
  gl.uniform3fv(hTranslate, translateVector);

  gl.uniform4f(hLightPos, 0.5, 1.0, 1.0, 0.0);
  gl.uniform4f(hColor, cubeColor[0], cubeColor[1], cubeColor[2], cubeColor[3]);

    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBuf);
        gl.enableVertexAttribArray(vaPosition);
        gl.vertexAttribPointer(vaPosition, 3, gl.FLOAT, false, 0, 0);
        
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeNBuf);
        gl.enableVertexAttribArray(vaNormal);
        gl.vertexAttribPointer(vaNormal, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIdxBuf);
    gl.drawElements(gl.TRIANGLES, cubeIdx.length, gl.UNSIGNED_SHORT, 0);
 
    currentAngle += 0.45;
    if (currentAngle > 360) {
        currentAngle -= 360;
    }
}

currentAngle = 0.0;
incAngle = 0.1;
</script>
</head>
<body onload="start()">
<canvas id="glcanvas" width="640" height="480"></canvas>
</body>
</html>

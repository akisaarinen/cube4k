<!DOCTYPE html>
<html lang="en">
<head>
<title>Shader</title>
<script>document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')</script>
<script id="shade_vert" type="x-shader/x-vertex">
    precision mediump float;
    
    uniform mat3 gRotate;
    uniform vec3 gTranslate;
    
    uniform vec4 gLightPos;
    uniform vec4 gColor;

    uniform float gAngleX;

    mat4 viewpoint = mat4(
      1, 0, 0, 0, 
      0, 0.8944271802902222, 0.4472135901451111, 0, 
      0, -0.4472135901451111, 0.8944271802902222, 0, 
      0, 0, -4.4721360206604, 1
    );

    mat4 projection = mat4(
      1.299038052558899, 0, 0, 0, 
      0, 1.7320507764816284, 0, 0, 
      0, 0, -1.0202020406723022, -1, 
      0, 0, -0.20202019810676575, 0
    );
    
    attribute vec3 vPosition;
    attribute vec3 vNormal;
    
    varying vec4 fColor;

    mat4 transpose(mat4 R) {
      return mat4(
        R[0][0], R[1][0], R[2][0], R[3][0],
        R[0][1], R[1][1], R[2][1], R[3][1],
        R[0][2], R[1][2], R[2][2], R[3][2],
        R[0][3], R[1][3], R[2][3], R[3][3]
      );
    }

    mat3 transpose(mat3 R) {
      return mat3(
        R[0][0], R[1][0], R[2][0],
        R[0][1], R[1][1], R[2][1],
        R[0][2], R[1][2], R[2][2]
      );
    }

    mat4 inverse(mat3 R, vec3 t)
    {
      mat3 Rt = transpose(R);
      vec3 th = Rt*t;
      return mat4(
        R[0][0], R[1][0], R[2][0], 0,
        R[0][1], R[1][1], R[2][1], 0,
        R[0][2], R[1][2], R[2][2], 0,
        -th[0],  -th[1],  -th[2],  1
      );
    }

    mat3 rotatex(float t) {
      return mat3(
          1,      0,       0,
          0, cos(t), -sin(t),
          0, sin(t),  cos(t)
      );
    }
    mat3 rotatey(float t) {
      return mat3(
         cos(t), 0, sin(t),
        0,       1,      0,
        -sin(t), 0, cos(t)
      );
    }
    mat3 rotatez(float t) {
      return mat3(
        cos(t), -sin(t), 0,
        sin(t),  cos(t), 0,
             0,       0, 1
      );
    }

    mat4 view4(mat3 M) {
      return mat4(
        M[0][0], M[0][1], M[0][2], 0,
        M[1][0], M[1][1], M[1][2], 0,
        M[2][0], M[2][1], M[2][2], 0,
        0, 0, 0, 1
      );
    }
    
    void main(void)
    {
        vec4 eyeNorm, eyePos, lightDir, pos;
        mat4 dummy;
        float NdotL, diffuse;

        mat3 R = rotatex(gAngleX) * rotatey(gAngleX/2.0);

        mat4 view = viewpoint * view4(R);
        mat4 normal = viewpoint * transpose(inverse(R, gTranslate));

        eyeNorm = normalize(normal * vec4(vNormal, 0));
        eyePos  = view * vec4(vPosition, 1);        
        
        lightDir = normalize(gLightPos - eyePos);
        NdotL = max(dot(eyeNorm.xyz, lightDir.xyz), 0.0);
        
        fColor = vec4(gColor.rgb * NdotL, 1);
        
        pos = vec4(vPosition, 1);
        gl_Position = projection * view * pos;
    }
</script>
<!--
      M = {
        {R11, R12, R13, 0},
        {R21, R22, R23, 0},
        {R31, R32, R33, 0},
        {tx, ty, tz, 1},
      };

      Rt = {
        {R11, R21, R31},
        {R12, R22, R32},
        {R13, R23, R33}
      }

      Rt*t = t'

      M-1 = {
        {R11, R21, R31, 0},
        {R12, R22, R32, 0},
        {R13, R23, R33, 0},
        {-t'x, -t'y, -t'z, 1},
      };
      -->
<script id="shade_frag" type="x-shader/x-fragment">

    //#version 100
    // Must specify precision in WebGL frag shaders
    precision mediump float;
    
    varying vec4 fColor;
    varying vec4 bColor;
    
    void main(void)
    {
        // Want to see polygons in wrong order
        if (gl_FrontFacing)
            gl_FragColor = fColor;
        else
            gl_FragColor = vec4(1,0,0,1);
    }
</script>
<script src="gpu.js"></script>
<script>

function start() {
  var canvas = document.getElementById("glcanvas");
  gl = canvas.getContext("webgl");

  gl.viewportWidth = canvas.width;
  gl.viewportHeight = canvas.height;

  gl.clearColor(0.0, 0.0, 0.0, 1.0);                      // Set clear color to black, fully opaque
  gl.enable(gl.DEPTH_TEST);                               // Enable depth testing
  gl.depthFunc(gl.LEQUAL);                                // Near things obscure far things
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);      // Clear the color as well as the depth buffer.

  initShaders();
  myCube();
  drawPicture(gl);
}

var initShaders = function()
{
  var vShader, fShader;

  vShader = gpu.loadShader(gl.VERTEX_SHADER, "shade_vert");
  fShader = gpu.loadShader(gl.FRAGMENT_SHADER, "shade_frag");
  gpuShade = gpu.newProgram(vShader, fShader);

  hNormalMatrix     = gl.getUniformLocation(gpuShade, "gNormalMatrix");
  hLightPos         = gl.getUniformLocation(gpuShade, "gLightPos");

  hRotate            = gl.getUniformLocation(gpuShade, "gRotate");
  hTranslate         = gl.getUniformLocation(gpuShade, "gTranslate");
  hAngleX         = gl.getUniformLocation(gpuShade, "gAngleX");

  hColor            = gl.getUniformLocation(gpuShade, "gColor");
  hColor            = gl.getUniformLocation(gpuShade, "gColor");

  vaPosition = gl.getAttribLocation(gpuShade, "vPosition");
  vaNormal   = gl.getAttribLocation(gpuShade, "vNormal");
};

function drawPicture(gl)
{
  // Clear the canvas
  gl.viewport(0,0, gl.viewportWidth, gl.viewportHeight);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  setProjection();
  setViewpoint();
  drawWorld();
  requestAnimationFrame(function() { drawPicture(gl); });
}


function setProjection() {
  pMatrix = new Float32Array(
  [1.299038052558899, 0, 0, 0, 
   0, 1.7320507764816284, 0, 0, 
   0, 0, -1.0202020406723022, -1, 
   0, 0, -0.20202019810676575, 0]);
}

function setViewpoint() {
  mvMatrix = new Float32Array(
    [1, 0, 0, 0, 
    0, 0.8944271802902222, 0.4472135901451111, 0, 
    0, -0.4472135901451111, 0.8944271802902222, 0, 
    0, 0, -4.4721360206604, 1]
  );
}

// Cube geometry
var cubeVerts = new Float32Array([
    -0.5,  0.5,  0.5,   // 0
    -0.5, -0.5,  0.5,
     0.5,  0.5,  0.5,
     0.5, -0.5,  0.5,
    -0.5,  0.5, -0.5,   // 4
    -0.5, -0.5, -0.5,
    -0.5,  0.5,  0.5,
    -0.5, -0.5,  0.5,
     0.5,  0.5, -0.5,   // 8
    -0.5,  0.5, -0.5,
     0.5,  0.5,  0.5,
    -0.5,  0.5,  0.5,
     0.5,  0.5,  0.5,   // 12
     0.5, -0.5,  0.5,
     0.5,  0.5, -0.5,
     0.5, -0.5, -0.5,
     0.5, -0.5,  0.5,   // 16
    -0.5, -0.5,  0.5,
     0.5, -0.5, -0.5,
    -0.5, -0.5, -0.5,
     0.5,  0.5, -0.5,   // 20
     0.5, -0.5, -0.5,
    -0.5,  0.5, -0.5,
    -0.5, -0.5, -0.5,
]);

var cubeNorms = new Float32Array([
     0,  0,  1,
     0,  0,  1,
     0,  0,  1,
     0,  0,  1,
    -1,  0,  0,
    -1,  0,  0,
    -1,  0,  0,
    -1,  0,  0,
     0,  1,  0,
     0,  1,  0,
     0,  1,  0,
     0,  1,  0,
     1,  0,  0,
     1,  0,  0,
     1,  0,  0,
     1,  0,  0,
     0, -1,  0,
     0, -1,  0,
     0, -1,  0,
     0, -1,  0,
     0,  0, -1,
     0,  0, -1,
     0,  0, -1,
     0,  0, -1,
]);

var cubeIdx = new Uint16Array([
     0,  1,  2,  1,  3,  2,
     4,  5,  6,  5,  7,  6,
     8,  9, 10,  9, 11, 10,
    12, 13, 14, 13, 15, 14,
    16, 17, 18, 17, 19, 18,
    20, 21, 22, 21, 23, 22,
]);

var myCube = function()
{
        // Transfer data to GPU
        cubeVBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBuf);
        gl.bufferData(gl.ARRAY_BUFFER, cubeVerts, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        
        cubeNBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeNBuf);
        gl.bufferData(gl.ARRAY_BUFFER, cubeNorms, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        
        cubeIdxBuf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIdxBuf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIdx, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
};


function drawWorld() {
  cubeColor = [0,1,0,1];

  gl.useProgram(gpuShade);

  var rotationMatrix = new Float32Array([
    1, 0, 0,
    0, 1, 0,
    0, 0, 1
  ]);
  
  var translateVector = new Float32Array([0, 0, 0]);

  gl.uniformMatrix3fv(hRotate, false, rotationMatrix);
  gl.uniform1f(hAngleX, currentAngle / 2.0 / Math.PI);
  gl.uniform3fv(hTranslate, translateVector);

  gl.uniform4f(hLightPos, 0.5, 1.0, 1.0, 0.0);
  gl.uniform4f(hColor, cubeColor[0], cubeColor[1], cubeColor[2], cubeColor[3]);

    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBuf);
        gl.enableVertexAttribArray(vaPosition);
        gl.vertexAttribPointer(vaPosition, 3, gl.FLOAT, false, 0, 0);
        
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeNBuf);
        gl.enableVertexAttribArray(vaNormal);
        gl.vertexAttribPointer(vaNormal, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIdxBuf);
    gl.drawElements(gl.TRIANGLES, cubeIdx.length, gl.UNSIGNED_SHORT, 0);
 
    currentAngle += 0.45;
    if (currentAngle > 360) {
        currentAngle -= 360;
    }
}

currentAngle = 0.0;
incAngle = 0.1;
</script>
</head>
<body onload="start()">
<canvas id="glcanvas" width="640" height="480"></canvas>
</body>
</html>
